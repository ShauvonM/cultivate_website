{"version":3,"sources":["../src/ts/app/service/lab.service.ts"],"names":[],"mappings":"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","file":"lab.service.js","sourcesContent":["import { Injectable } from '@angular/core';\r\n\r\nimport moment = require('moment');\r\n\r\nimport { LABS } from '../data/labs.data';\r\nimport { Person, TeamService } from './team.service';\r\nimport DateUtils from '../util/date.utils';\r\n\r\nexport class Lab {\r\n    uuid: string;\r\n    name: string;\r\n\r\n    inactive?: boolean;\r\n\r\n    format: string; // what sort of event this is, i.e. \"class\" \"drop-in\" \"meet-up\"\r\n\r\n    dates: string[]; // ISO 8601 - '2016-11-07'\r\n    times: string[]; // ISO 8601, include timezone - '17:30:00-500' is 5:30 PM Eastern\r\n    durations: number[]; // in minutes\r\n    // these things are arrays, in case this item repeats irregularly\r\n    // they should be the same length - if there are multiple dates and only one time and duration,\r\n    // we can assume that this event is the same time and duration on each date\r\n\r\n    // I'm pretty sure that if these arrays are bigger than one, the repeatType needs to be 0 (or not set)\r\n\r\n    // note that the intention here is not for multiple offerings of the same one-off class, \r\n    //  but multiple sessions of a single class that happen on different days or times\r\n\r\n    price?: number; // USD\r\n\r\n    // TODO: do we need a SKU or something for purchasing?\r\n\r\n    blurb: string;\r\n    description: string;\r\n    icon?: string;\r\n    \r\n    location?: string; // leave blank to default to \"The Studio\"\r\n\r\n    teacherKey: string;\r\n\r\n    // TODO: add tags\r\n    // TODO: a \"theme\" field?\r\n    // TODO: a \"who is this for\" field?\r\n\r\n    image?: string;\r\n\r\n    spaces?: number; // number of seats total\r\n    minSpaces?: number; // number required to go\r\n    spacesSold?: number; // number of seats sold\r\n\r\n    repeatType?: number; // see below\r\n    sessionCount?: number; // total number of sessions - if repeatType is set, 0 is indefinite\r\n    repeatInterval?: number; // every [interval] days, weeks, etc (0 or 1 are treated as 'every')\r\n}\r\n\r\n/**\r\n * Repeat types:\r\n * 0 - does not repeat\r\n * 1 - daily            (every day)\r\n * 2 - weekly           (ex. every Wednesday)\r\n * 3 - monthly by day   (ex. the 1st of every month)\r\n * 4 - monthly by week  (ex. the last monday of every month)\r\n * 5 - yearly\r\n */\r\n\r\n@Injectable()\r\nexport class LabService {\r\n    private labs: Lab[] = [];\r\n\r\n    constructor(\r\n        private teamService: TeamService\r\n    ) { }\r\n\r\n    getLabs(format: string): Promise<Lab[]> {\r\n        return new Promise<Lab[]>((resolve, reject) => {\r\n            this._getLabs().then((labs) => {\r\n                let classes: Lab[] = [];\r\n                this.labs.forEach(lab => {\r\n                    // TODO: make this an enum?\r\n                    if ((format == \"all\" || lab.format == format)\r\n                        && !lab.inactive) {\r\n\r\n                        classes.push(lab);\r\n                    }\r\n                });\r\n                classes.sort((lab1, lab2) => {\r\n                    let val1 = lab1.dates[0];\r\n                    let val2 = lab2.dates[0];\r\n                    if (val1 > val2) {\r\n                        return 1;\r\n                    }\r\n                    if (val1 < val2) {\r\n                        return -1;\r\n                    }\r\n                    return 0;\r\n                });\r\n                resolve(classes);\r\n            })\r\n        })\r\n    }\r\n\r\n    private _labPromise: Promise<Lab[]>;\r\n    private _getLabs(): Promise<Lab[]> {\r\n        if (!this._labPromise) {\r\n            this._labPromise = new Promise<Lab[]>((resolve, reject) => {\r\n                this.labs = LABS;\r\n                resolve(this.labs);\r\n            });\r\n        }\r\n        return this._labPromise;\r\n    }\r\n\r\n    getLabsForDate(date: moment.Moment): Lab[] {\r\n        let dateLabs: Lab[] = [];\r\n        this.labs.forEach((lab) => {\r\n            // do a bit of searching just to see if we even need to check the dates\r\n            if (lab.repeatType) {\r\n                if (date.isBefore(DateUtils.getStartMomentForLab(lab), 'day')) {\r\n                    // it starts in the future, so we can skip it\r\n                    return true; // this skips to the next item in the foreEach\r\n                } else if (lab.sessionCount && date.isAfter(DateUtils.getEndMomentForLab(lab), 'day')) {\r\n                    // the lab ended in the past, so we can skip it\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            if (this.isLabOnDate(lab, date)) {\r\n                dateLabs.push(lab);\r\n            }\r\n        });\r\n        return dateLabs;\r\n    }\r\n\r\n    isLabOnDate (lab: Lab, date: moment.Moment): boolean {\r\n        if (lab.repeatType && !lab.sessionCount) {\r\n            let startMoment = DateUtils.getStartMomentForLab(lab);\r\n            if (date.isBefore(startMoment, \"day\")) {\r\n                return false;\r\n            }\r\n\r\n            // if it's an endless repeat, we can just check it against the day it regularly happens\r\n            switch (lab.repeatType) {\r\n                case 1: // daily\r\n                    // it happens every day, so yes it happens today\r\n                    return true;\r\n                case 2: // weekly\r\n                    return DateUtils.getStartMomentForLab(lab).day() == date.day();\r\n                case 3: // monthly by day\r\n                    return DateUtils.getStartMomentForLab(lab).date() == date.date();\r\n                case 4: // monthly by week\r\n                    let weekInMonth = DateUtils.getWeekInMonth(startMoment);\r\n                    let dayInWeek = startMoment.day();\r\n                    return DateUtils.getWeekInMonth(date) == weekInMonth\r\n                        && date.day() == dayInWeek;\r\n                case 5: // annual\r\n                    return startMoment.format(\"MM-DD\") == date.format(\"MM-DD\");\r\n            }\r\n        } else {\r\n            return DateUtils.getAllDatesForLab(lab).indexOf(DateUtils.getISODate(date)) > -1;\r\n        }\r\n    }\r\n\r\n    getLab(uuid: string): Promise<Lab> {\r\n        return new Promise<Lab>((resolve, reject) => {\r\n            this.getLabs(\"all\").then((labs) => {\r\n                labs.forEach((lab) => {\r\n                    if (lab.uuid == uuid) {\r\n                        resolve(lab);\r\n                    }\r\n                })\r\n            })\r\n        })\r\n    }\r\n\r\n}"]}